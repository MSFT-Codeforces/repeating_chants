**Problem Statement**
You are given an integer array \(a[1], a[2], \dots, a[n]\).

A **block** is any contiguous subarray \(a[l], a[l+1], \dots, a[r]\) where \(1 \le l \le r \le n\). So each block is described by a pair of indices \((l, r)\).

Your task is to find a set of blocks
\[
(l_1,r_1), (l_2,r_2), \dots, (l_k,r_k)
\]
such that:

1. **Blocks do not intersect (are disjoint):** for any \(i \ne j\), either \(r_i < l_j\) or \(r_j < l_i\).
2. **All blocks have the same sum:**
\[
\sum_{t=l_1}^{r_1} a[t] = \sum_{t=l_2}^{r_2} a[t] = \dots = \sum_{t=l_k}^{r_k} a[t].
\]
3. **The number of blocks \(k\) is maximum** among all sets satisfying the above conditions.

Print any maximum-size valid set.

**Input Format**
- The first line contains an integer \(n\) \((1 \le n \le 50)\) — the array length.
- The second line contains \(n\) integers \(a[1], a[2], \dots, a[n]\) \(( -10^5 \le a_i \le 10^5 )\).

**Output Format**
- Print an integer \(k\) — the maximum number of disjoint blocks with equal sum.
- Then print \(k\) lines, each containing two integers \(l_i\) and \(r_i\) \((1 \le l_i \le r_i \le n)\) describing the blocks.
- The blocks may be printed in any order. If multiple answers exist, print any of them.

**Examples**
Sample Input 1
```
7
4 1 2 2 1 5 3
```
Sample Output 1
```
3
7 7
2 3
4 5
```

Sample Input 2
```
11
-5 -4 -3 -2 -1 0 1 2 3 4 5
```
Sample Output 2
```
2
3 4
1 1
```

Sample Input 3
```
4
1 1 1 1
```
Sample Output 3
```
4
4 4
1 1
2 2
3 3
```

**Editorial**
Let \(pref[i] = a[1] + a[2] + \dots + a[i]\) with \(pref[0]=0\).  
Then the sum of a block \((l,r)\) is:
\[
sum(l,r) = pref[r] - pref[l-1].
\]

1. **Generate all blocks and group by sum.**  
   For every \(1 \le l \le r \le n\), compute \(s = pref[r] - pref[l-1]\) and store the interval \((l,r)\) in a map `sum -> list of intervals`.

2. **For each sum, choose the maximum number of disjoint intervals.**  
   This becomes the classic interval scheduling problem:
   - Sort intervals by increasing right endpoint \(r\).
   - Greedily take an interval if its left endpoint \(l\) is strictly greater than the right endpoint of the last chosen interval.

   This greedy is optimal for maximizing the number of non-overlapping intervals when sorted by end time.

3. **Pick the best sum.**  
   Apply the greedy selection for every sum group and keep the group that yields the largest number of chosen blocks.

Complexity:
- There are \(O(n^2)\) blocks.
- Sorting within groups leads to at most \(O(n^2 \log n)\) total work, which is easily fast for \(n \le 50\).

**Code**
```python
import sys
from collections import defaultdict

def select_max_non_overlapping(intervals):
    # Sort by right endpoint
    intervals.sort(key=lambda x: x[1])
    ans = []
    last_r = -10**18
    for l, r in intervals:
        if l > last_r:
            ans.append((l, r))
            last_r = r
    return ans

def main():
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    a = [0] + list(map(int, data[1:1+n]))

    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + a[i]

    mp = defaultdict(list)
    for l in range(1, n + 1):
        for r in range(l, n + 1):
            s = pref[r] - pref[l - 1]
            mp[s].append((l, r))

    best = []
    for intervals in mp.values():
        cur = select_max_non_overlapping(intervals[:])
        if len(cur) > len(best):
            best = cur

    out = [str(len(best))]
    out.extend(f"{l} {r}" for l, r in best)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
```